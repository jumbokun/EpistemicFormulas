# AEDNF 去内省算法分析与实现

## 数学定义回顾

根据提供的数学定义，AEDNF的去内省形式 `D_a[Φ]` 定义如下：

### 基本情形
当 `ℓ_Φ = 0` 时（即整个公式都是 a-客观的）：
```
D_a[Φ] = K_a(Φ)
```

### 递归情形
当 `ℓ_Φ = m > 0` 时（即存在 a-主观部分）：
```
D_a[Φ] = D_a[V_{m-1} ∨ ⋁_{i=m+1}^n Ω_i] ∨ ⋁_{C∈C(D_a[V_{m-1} ∨ ⋁_{i=m}^n Ω_i])} (C ∧ Θ_m)
```

其中：
- `V_m = (Ω₁ ∧ Θ₁) ∨ (Ω₂ ∧ Θ₂) ∨ ... ∨ (Ω_m ∧ Θ_m)`
- `Ω_i` 是第 i 项的 a-客观部分
- `Θ_i` 是第 i 项的 a-主观部分
- `C(Ψ)` 是 AEDNF Ψ 的子句集合

## 算法实现

### 核心函数

1. **`decompose_term_by_agent(term, agent)`**
   - 将 AEDNF 项分解为 (Ω_i, Θ_i) 对
   - Ω_i: a-客观部分（命题部分 + 非a代理的知识文字）
   - Θ_i: a-主观部分（a代理的知识文字）

2. **`find_critical_index(phi, agent)`**
   - 找到临界点 ℓ_Φ：最大的非a-客观子句的索引
   - 当 ℓ_Φ = 0 时，整个公式都是 a-客观的

3. **`deintrospective_k(phi, agent)`**
   - 主要的去内省函数
   - 根据临界点决定使用基本情形还是递归情形

4. **`apply_deintrospective_formula(phi, agent, m)`**
   - 应用递归公式
   - 构造 V_{m-1}、Ω_i 的析取等子公式
   - 递归计算并组合结果

### 辅助函数

1. **`create_vm(phi, agent, m)`**
   - 构造 V_m = (Ω₁ ∧ Θ₁) ∨ (Ω₂ ∧ Θ₂) ∨ ... ∨ (Ω_m ∧ Θ_m)

2. **`create_omega_disjunction(phi, agent, start_idx, end_idx)`**
   - 构造 ⋁_{i=start_idx}^{end_idx} Ω_i

3. **`get_clauses_from_aednf(phi)`**
   - 从 AEDNF 中获取所有项（作为子句）

## 测试结果分析

### 简单测试用例
**输入**: Φ = (v1 ∧ K_a(p))
**期望输出**: D_a[Φ] = K_a(v1) ∧ K_a(p)
**实际输出**: 包含 a-主观部分的复杂形式

### 复杂测试用例
**输入**: Φ = (v1 ∧ K_a(p)) ∨ (v2 ∧ K_b(q)) ∨ v3
**期望输出**: 所有a-主观部分外提到最外层
**实际输出**: 结果中仍包含a-主观部分

## 问题分析

### 1. 算法理解问题
当前的实现可能没有正确理解数学定义的目标。去内省的目标应该是：
- 将 `K_a(Φ)` 转换为等价形式
- 其中所有a-主观部分都被外提到最外层
- 内部只包含a-客观公式

### 2. 递归公式应用问题
递归公式的复杂性可能导致：
- 递归深度过深
- 子公式构造错误
- 结果组合不正确

### 3. 数据结构问题
- AEDNF/AECNF 的构造可能不正确
- 逻辑操作（land, lor, know）的实现可能有问题
- 公式分解和重组的过程可能有误

## 改进建议

### 1. 重新审视数学定义
需要更仔细地理解：
- 递归公式的每一步含义
- 子公式的正确构造方法
- 结果的组合逻辑

### 2. 简化实现
考虑先实现简单情况：
- 只有一个主观项的情况
- 逐步扩展到多个主观项

### 3. 验证方法
建立验证机制：
- 检查结果是否等价于原始公式
- 验证a-主观部分是否正确外提
- 确保内部只包含a-客观公式

### 4. 调试工具
添加更多调试信息：
- 详细显示每一步的计算过程
- 可视化中间结果
- 跟踪递归调用

## 结论

当前的AEDNF去内省算法实现已经具备了基本框架，但在理解和实现数学定义的细节上还需要进一步改进。主要问题在于：

1. **算法理解**: 需要更准确地理解数学定义的目标和步骤
2. **实现细节**: 递归公式的应用需要更仔细的实现
3. **验证机制**: 需要建立有效的验证方法来确保结果的正确性

建议在继续开发之前，先深入理解数学定义，并建立更完善的测试和验证机制。
